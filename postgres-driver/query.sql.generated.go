// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: query.sql

package postgresdriver

import (
	"context"
	"database/sql"
	"encoding/json"

	"github.com/lib/pq"
	"github.com/vishruthsk/portal-db/types"
)

const activateBlockchain = `-- name: ActivateBlockchain :exec
UPDATE blockchains
SET active = $2,
    updated_at = $3
WHERE blockchain_id = $1
`

type ActivateBlockchainParams struct {
	BlockchainID string       `json:"blockchainID"`
	Active       sql.NullBool `json:"active"`
	UpdatedAt    sql.NullTime `json:"updatedAt"`
}

func (q *Queries) ActivateBlockchain(ctx context.Context, arg ActivateBlockchainParams) error {
	_, err := q.db.ExecContext(ctx, activateBlockchain, arg.BlockchainID, arg.Active, arg.UpdatedAt)
	return err
}

const deleteUserAccess = `-- name: DeleteUserAccess :exec
DELETE FROM user_access
WHERE user_id = $1
    AND lb_id = $2
`

type DeleteUserAccessParams struct {
	UserID sql.NullString `json:"userID"`
	LbID   sql.NullString `json:"lbID"`
}

func (q *Queries) DeleteUserAccess(ctx context.Context, arg DeleteUserAccessParams) error {
	_, err := q.db.ExecContext(ctx, deleteUserAccess, arg.UserID, arg.LbID)
	return err
}

const insertAppLimit = `-- name: InsertAppLimit :exec
INSERT into app_limits (application_id, pay_plan, custom_limit)
VALUES ($1, $2, $3)
`

type InsertAppLimitParams struct {
	ApplicationID string        `json:"applicationID"`
	PayPlan       string        `json:"payPlan"`
	CustomLimit   sql.NullInt32 `json:"customLimit"`
}

func (q *Queries) InsertAppLimit(ctx context.Context, arg InsertAppLimitParams) error {
	_, err := q.db.ExecContext(ctx, insertAppLimit, arg.ApplicationID, arg.PayPlan, arg.CustomLimit)
	return err
}

const insertApplication = `-- name: InsertApplication :exec
INSERT into applications (
        application_id,
        user_id,
        name,
        contact_email,
        description,
        owner,
        url,
        status,
        dummy,
        created_at,
        updated_at
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10,
        $11
    )
`

type InsertApplicationParams struct {
	ApplicationID string         `json:"applicationID"`
	UserID        sql.NullString `json:"userID"`
	Name          sql.NullString `json:"name"`
	ContactEmail  sql.NullString `json:"contactEmail"`
	Description   sql.NullString `json:"description"`
	Owner         sql.NullString `json:"owner"`
	Url           sql.NullString `json:"url"`
	Status        sql.NullString `json:"status"`
	Dummy         sql.NullBool   `json:"dummy"`
	CreatedAt     sql.NullTime   `json:"createdAt"`
	UpdatedAt     sql.NullTime   `json:"updatedAt"`
}

func (q *Queries) InsertApplication(ctx context.Context, arg InsertApplicationParams) error {
	_, err := q.db.ExecContext(ctx, insertApplication,
		arg.ApplicationID,
		arg.UserID,
		arg.Name,
		arg.ContactEmail,
		arg.Description,
		arg.Owner,
		arg.Url,
		arg.Status,
		arg.Dummy,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const insertBlockchain = `-- name: InsertBlockchain :exec
INSERT into blockchains (
        blockchain_id,
        active,
        altruist,
        blockchain,
        blockchain_aliases,
        chain_id,
        chain_id_check,
        description,
        enforce_result,
        log_limit_blocks,
        network,
        path,
        request_timeout,
        ticker,
        created_at,
        updated_at
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10,
        $11,
        $12,
        $13,
        $14,
        $15,
        $16
    )
`

type InsertBlockchainParams struct {
	BlockchainID      string         `json:"blockchainID"`
	Active            sql.NullBool   `json:"active"`
	Altruist          sql.NullString `json:"altruist"`
	Blockchain        sql.NullString `json:"blockchain"`
	BlockchainAliases []string       `json:"blockchainAliases"`
	ChainID           sql.NullString `json:"chainID"`
	ChainIDCheck      sql.NullString `json:"chainIDCheck"`
	Description       sql.NullString `json:"description"`
	EnforceResult     sql.NullString `json:"enforceResult"`
	LogLimitBlocks    sql.NullInt32  `json:"logLimitBlocks"`
	Network           sql.NullString `json:"network"`
	Path              sql.NullString `json:"path"`
	RequestTimeout    sql.NullInt32  `json:"requestTimeout"`
	Ticker            sql.NullString `json:"ticker"`
	CreatedAt         sql.NullTime   `json:"createdAt"`
	UpdatedAt         sql.NullTime   `json:"updatedAt"`
}

func (q *Queries) InsertBlockchain(ctx context.Context, arg InsertBlockchainParams) error {
	_, err := q.db.ExecContext(ctx, insertBlockchain,
		arg.BlockchainID,
		arg.Active,
		arg.Altruist,
		arg.Blockchain,
		pq.Array(arg.BlockchainAliases),
		arg.ChainID,
		arg.ChainIDCheck,
		arg.Description,
		arg.EnforceResult,
		arg.LogLimitBlocks,
		arg.Network,
		arg.Path,
		arg.RequestTimeout,
		arg.Ticker,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const insertGatewayAAT = `-- name: InsertGatewayAAT :exec
INSERT into gateway_aat (
        application_id,
        address,
        client_public_key,
        private_key,
        public_key,
        signature,
        version
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7
    )
`

type InsertGatewayAATParams struct {
	ApplicationID   string         `json:"applicationID"`
	Address         string         `json:"address"`
	ClientPublicKey string         `json:"clientPublicKey"`
	PrivateKey      sql.NullString `json:"privateKey"`
	PublicKey       string         `json:"publicKey"`
	Signature       string         `json:"signature"`
	Version         sql.NullString `json:"version"`
}

func (q *Queries) InsertGatewayAAT(ctx context.Context, arg InsertGatewayAATParams) error {
	_, err := q.db.ExecContext(ctx, insertGatewayAAT,
		arg.ApplicationID,
		arg.Address,
		arg.ClientPublicKey,
		arg.PrivateKey,
		arg.PublicKey,
		arg.Signature,
		arg.Version,
	)
	return err
}

const insertGatewaySettings = `-- name: InsertGatewaySettings :exec
INSERT into gateway_settings (
        application_id,
        secret_key,
        secret_key_required
    )
VALUES (
        $1,
        $2,
        $3
    )
`

type InsertGatewaySettingsParams struct {
	ApplicationID     string         `json:"applicationID"`
	SecretKey         sql.NullString `json:"secretKey"`
	SecretKeyRequired sql.NullBool   `json:"secretKeyRequired"`
}

func (q *Queries) InsertGatewaySettings(ctx context.Context, arg InsertGatewaySettingsParams) error {
	_, err := q.db.ExecContext(ctx, insertGatewaySettings, arg.ApplicationID, arg.SecretKey, arg.SecretKeyRequired)
	return err
}

const insertLbApps = `-- name: InsertLbApps :exec
INSERT into lb_apps (lb_id, app_id)
SELECT $1,
    unnest($2::VARCHAR [])
`

type InsertLbAppsParams struct {
	LbID   string   `json:"lbID"`
	AppIds []string `json:"appIds"`
}

func (q *Queries) InsertLbApps(ctx context.Context, arg InsertLbAppsParams) error {
	_, err := q.db.ExecContext(ctx, insertLbApps, arg.LbID, pq.Array(arg.AppIds))
	return err
}

const insertLoadBalancer = `-- name: InsertLoadBalancer :exec
INSERT into loadbalancers (
        lb_id,
        name,
        user_id,
        request_timeout,
        gigastake,
        gigastake_redirect,
        created_at,
        updated_at
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8
    )
`

type InsertLoadBalancerParams struct {
	LbID              string         `json:"lbID"`
	Name              sql.NullString `json:"name"`
	UserID            sql.NullString `json:"userID"`
	RequestTimeout    sql.NullInt32  `json:"requestTimeout"`
	Gigastake         sql.NullBool   `json:"gigastake"`
	GigastakeRedirect sql.NullBool   `json:"gigastakeRedirect"`
	CreatedAt         sql.NullTime   `json:"createdAt"`
	UpdatedAt         sql.NullTime   `json:"updatedAt"`
}

func (q *Queries) InsertLoadBalancer(ctx context.Context, arg InsertLoadBalancerParams) error {
	_, err := q.db.ExecContext(ctx, insertLoadBalancer,
		arg.LbID,
		arg.Name,
		arg.UserID,
		arg.RequestTimeout,
		arg.Gigastake,
		arg.GigastakeRedirect,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const insertNotificationSettings = `-- name: InsertNotificationSettings :exec
INSERT into notification_settings (
        application_id,
        signed_up,
        on_quarter,
        on_half,
        on_three_quarters,
        on_full
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6
    )
`

type InsertNotificationSettingsParams struct {
	ApplicationID   string       `json:"applicationID"`
	SignedUp        sql.NullBool `json:"signedUp"`
	OnQuarter       sql.NullBool `json:"onQuarter"`
	OnHalf          sql.NullBool `json:"onHalf"`
	OnThreeQuarters sql.NullBool `json:"onThreeQuarters"`
	OnFull          sql.NullBool `json:"onFull"`
}

func (q *Queries) InsertNotificationSettings(ctx context.Context, arg InsertNotificationSettingsParams) error {
	_, err := q.db.ExecContext(ctx, insertNotificationSettings,
		arg.ApplicationID,
		arg.SignedUp,
		arg.OnQuarter,
		arg.OnHalf,
		arg.OnThreeQuarters,
		arg.OnFull,
	)
	return err
}

const insertRedirect = `-- name: InsertRedirect :exec
INSERT into redirects (
        blockchain_id,
        alias,
        loadbalancer,
        domain,
        created_at,
        updated_at
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6
    )
`

type InsertRedirectParams struct {
	BlockchainID string       `json:"blockchainID"`
	Alias        string       `json:"alias"`
	Loadbalancer string       `json:"loadbalancer"`
	Domain       string       `json:"domain"`
	CreatedAt    sql.NullTime `json:"createdAt"`
	UpdatedAt    sql.NullTime `json:"updatedAt"`
}

func (q *Queries) InsertRedirect(ctx context.Context, arg InsertRedirectParams) error {
	_, err := q.db.ExecContext(ctx, insertRedirect,
		arg.BlockchainID,
		arg.Alias,
		arg.Loadbalancer,
		arg.Domain,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const insertStickinessOptions = `-- name: InsertStickinessOptions :exec
INSERT INTO stickiness_options (
        lb_id,
        duration,
        sticky_max,
        stickiness,
        origins
    )
VALUES ($1, $2, $3, $4, $5)
`

type InsertStickinessOptionsParams struct {
	LbID       string         `json:"lbID"`
	Duration   sql.NullString `json:"duration"`
	StickyMax  sql.NullInt32  `json:"stickyMax"`
	Stickiness sql.NullBool   `json:"stickiness"`
	Origins    []string       `json:"origins"`
}

func (q *Queries) InsertStickinessOptions(ctx context.Context, arg InsertStickinessOptionsParams) error {
	_, err := q.db.ExecContext(ctx, insertStickinessOptions,
		arg.LbID,
		arg.Duration,
		arg.StickyMax,
		arg.Stickiness,
		pq.Array(arg.Origins),
	)
	return err
}

const insertSyncCheckOptions = `-- name: InsertSyncCheckOptions :exec
INSERT into sync_check_options (
        blockchain_id,
        synccheck,
        allowance,
        body,
        path,
        result_key
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6
    )
`

type InsertSyncCheckOptionsParams struct {
	BlockchainID string         `json:"blockchainID"`
	Synccheck    sql.NullString `json:"synccheck"`
	Allowance    sql.NullInt32  `json:"allowance"`
	Body         sql.NullString `json:"body"`
	Path         sql.NullString `json:"path"`
	ResultKey    sql.NullString `json:"resultKey"`
}

func (q *Queries) InsertSyncCheckOptions(ctx context.Context, arg InsertSyncCheckOptionsParams) error {
	_, err := q.db.ExecContext(ctx, insertSyncCheckOptions,
		arg.BlockchainID,
		arg.Synccheck,
		arg.Allowance,
		arg.Body,
		arg.Path,
		arg.ResultKey,
	)
	return err
}

const insertUserAccess = `-- name: InsertUserAccess :exec
INSERT INTO user_access (
        lb_id,
        role_name,
        user_id,
        email,
        accepted,
        created_at,
        updated_at
    )
VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type InsertUserAccessParams struct {
	LbID      sql.NullString `json:"lbID"`
	RoleName  sql.NullString `json:"roleName"`
	UserID    sql.NullString `json:"userID"`
	Email     sql.NullString `json:"email"`
	Accepted  sql.NullBool   `json:"accepted"`
	CreatedAt sql.NullTime   `json:"createdAt"`
	UpdatedAt sql.NullTime   `json:"updatedAt"`
}

func (q *Queries) InsertUserAccess(ctx context.Context, arg InsertUserAccessParams) error {
	_, err := q.db.ExecContext(ctx, insertUserAccess,
		arg.LbID,
		arg.RoleName,
		arg.UserID,
		arg.Email,
		arg.Accepted,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const removeApp = `-- name: RemoveApp :exec
UPDATE applications
SET status = COALESCE($2, status)
WHERE application_id = $1
`

type RemoveAppParams struct {
	ApplicationID string         `json:"applicationID"`
	Status        sql.NullString `json:"status"`
}

func (q *Queries) RemoveApp(ctx context.Context, arg RemoveAppParams) error {
	_, err := q.db.ExecContext(ctx, removeApp, arg.ApplicationID, arg.Status)
	return err
}

const removeLB = `-- name: RemoveLB :exec
UPDATE loadbalancers
SET user_id = '',
    updated_at = $2
WHERE lb_id = $1
`

type RemoveLBParams struct {
	LbID      string       `json:"lbID"`
	UpdatedAt sql.NullTime `json:"updatedAt"`
}

func (q *Queries) RemoveLB(ctx context.Context, arg RemoveLBParams) error {
	_, err := q.db.ExecContext(ctx, removeLB, arg.LbID, arg.UpdatedAt)
	return err
}

const selectAppLimit = `-- name: SelectAppLimit :one
SELECT application_id,
    pay_plan,
    custom_limit
FROM app_limits
WHERE application_id = $1
`

type SelectAppLimitRow struct {
	ApplicationID string        `json:"applicationID"`
	PayPlan       string        `json:"payPlan"`
	CustomLimit   sql.NullInt32 `json:"customLimit"`
}

func (q *Queries) SelectAppLimit(ctx context.Context, applicationID string) (SelectAppLimitRow, error) {
	row := q.db.QueryRowContext(ctx, selectAppLimit, applicationID)
	var i SelectAppLimitRow
	err := row.Scan(&i.ApplicationID, &i.PayPlan, &i.CustomLimit)
	return i, err
}

const selectApplications = `-- name: SelectApplications :many
WITH app_whitelists AS (
    SELECT application_id
    FROM whitelist_contracts
    UNION
    SELECT application_id
    FROM whitelist_methods
)
SELECT a.application_id,
    a.contact_email,
    a.created_at,
    a.description,
    a.dummy,
    a.name,
    a.owner,
    a.status,
    a.updated_at,
    a.url,
    a.user_id,
    a.first_date_surpassed,
    ga.address AS ga_address,
    ga.client_public_key AS ga_client_public_key,
    ga.private_key AS ga_private_key,
    ga.public_key AS ga_public_key,
    ga.signature AS ga_signature,
    ga.version AS ga_version,
    gs.secret_key,
    gs.secret_key_required,
    gs.whitelist_blockchains,
    gs.whitelist_origins,
    gs.whitelist_user_agents,
    ns.signed_up,
    ns.on_quarter,
    ns.on_half,
    ns.on_three_quarters,
    ns.on_full,
    al.custom_limit,
    al.pay_plan,
    pp.daily_limit as plan_limit,
    CASE
        WHEN wc.application_id IS NOT NULL THEN json_agg(
            json_build_object(
                'blockchain_id',
                wc.blockchain_id,
                'contracts',
                wc.contracts
            )
        )::VARCHAR
        ELSE null
    END as whitelist_contracts,
    CASE
        WHEN wm.application_id IS NOT NULL THEN json_agg(
            json_build_object(
                'blockchain_id',
                wm.blockchain_id,
                'methods',
                wm.methods
            )
        )::VARCHAR
        ELSE null
    END as whitelist_methods
FROM applications AS a
    LEFT JOIN gateway_aat AS ga ON a.application_id = ga.application_id
    LEFT JOIN gateway_settings AS gs ON a.application_id = gs.application_id
    LEFT JOIN notification_settings AS ns ON a.application_id = ns.application_id
    LEFT JOIN app_limits AS al ON a.application_id = al.application_id
    LEFT JOIN pay_plans AS pp ON al.pay_plan = pp.plan_type
    LEFT JOIN whitelist_contracts wc ON a.application_id = wc.application_id
    LEFT JOIN whitelist_methods wm ON a.application_id = wm.application_id
GROUP BY a.application_id,
    a.contact_email,
    a.created_at,
    a.description,
    a.dummy,
    a.name,
    a.owner,
    a.status,
    a.updated_at,
    a.url,
    a.user_id,
    a.first_date_surpassed,
    ga.address,
    ga.client_public_key,
    ga.private_key,
    ga.public_key,
    ga.signature,
    ga.version,
    gs.secret_key,
    gs.secret_key_required,
    gs.whitelist_blockchains,
    gs.whitelist_origins,
    gs.whitelist_user_agents,
    ns.signed_up,
    ns.on_quarter,
    ns.on_half,
    ns.on_three_quarters,
    ns.on_full,
    al.custom_limit,
    al.pay_plan,
    pp.daily_limit,
    wc.application_id,
    wm.application_id
`

type SelectApplicationsRow struct {
	ApplicationID        string         `json:"applicationID"`
	ContactEmail         sql.NullString `json:"contactEmail"`
	CreatedAt            sql.NullTime   `json:"createdAt"`
	Description          sql.NullString `json:"description"`
	Dummy                sql.NullBool   `json:"dummy"`
	Name                 sql.NullString `json:"name"`
	Owner                sql.NullString `json:"owner"`
	Status               sql.NullString `json:"status"`
	UpdatedAt            sql.NullTime   `json:"updatedAt"`
	Url                  sql.NullString `json:"url"`
	UserID               sql.NullString `json:"userID"`
	FirstDateSurpassed   sql.NullTime   `json:"firstDateSurpassed"`
	GaAddress            sql.NullString `json:"gaAddress"`
	GaClientPublicKey    sql.NullString `json:"gaClientPublicKey"`
	GaPrivateKey         sql.NullString `json:"gaPrivateKey"`
	GaPublicKey          sql.NullString `json:"gaPublicKey"`
	GaSignature          sql.NullString `json:"gaSignature"`
	GaVersion            sql.NullString `json:"gaVersion"`
	SecretKey            sql.NullString `json:"secretKey"`
	SecretKeyRequired    sql.NullBool   `json:"secretKeyRequired"`
	WhitelistBlockchains []string       `json:"whitelistBlockchains"`
	WhitelistOrigins     []string       `json:"whitelistOrigins"`
	WhitelistUserAgents  []string       `json:"whitelistUserAgents"`
	SignedUp             sql.NullBool   `json:"signedUp"`
	OnQuarter            sql.NullBool   `json:"onQuarter"`
	OnHalf               sql.NullBool   `json:"onHalf"`
	OnThreeQuarters      sql.NullBool   `json:"onThreeQuarters"`
	OnFull               sql.NullBool   `json:"onFull"`
	CustomLimit          sql.NullInt32  `json:"customLimit"`
	PayPlan              sql.NullString `json:"payPlan"`
	PlanLimit            sql.NullInt32  `json:"planLimit"`
	WhitelistContracts   interface{}    `json:"whitelistContracts"`
	WhitelistMethods     interface{}    `json:"whitelistMethods"`
}

func (q *Queries) SelectApplications(ctx context.Context) ([]SelectApplicationsRow, error) {
	rows, err := q.db.QueryContext(ctx, selectApplications)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectApplicationsRow
	for rows.Next() {
		var i SelectApplicationsRow
		if err := rows.Scan(
			&i.ApplicationID,
			&i.ContactEmail,
			&i.CreatedAt,
			&i.Description,
			&i.Dummy,
			&i.Name,
			&i.Owner,
			&i.Status,
			&i.UpdatedAt,
			&i.Url,
			&i.UserID,
			&i.FirstDateSurpassed,
			&i.GaAddress,
			&i.GaClientPublicKey,
			&i.GaPrivateKey,
			&i.GaPublicKey,
			&i.GaSignature,
			&i.GaVersion,
			&i.SecretKey,
			&i.SecretKeyRequired,
			pq.Array(&i.WhitelistBlockchains),
			pq.Array(&i.WhitelistOrigins),
			pq.Array(&i.WhitelistUserAgents),
			&i.SignedUp,
			&i.OnQuarter,
			&i.OnHalf,
			&i.OnThreeQuarters,
			&i.OnFull,
			&i.CustomLimit,
			&i.PayPlan,
			&i.PlanLimit,
			&i.WhitelistContracts,
			&i.WhitelistMethods,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectBlockchains = `-- name: SelectBlockchains :many
SELECT b.blockchain_id,
    b.altruist,
    b.blockchain,
    b.blockchain_aliases,
    b.chain_id,
    b.chain_id_check,
    b.description,
    b.enforce_result,
    b.log_limit_blocks,
    b.network,
    b.path,
    b.request_timeout,
    b.ticker,
    b.active,
    s.synccheck AS s_sync_check,
    s.allowance AS s_allowance,
    s.body AS s_body,
    s.path AS s_path,
    s.result_key AS s_result_key,
    COALESCE(redirects.r, '[]') AS redirects,
    b.created_at,
    b.updated_at
FROM blockchains AS b
    LEFT JOIN sync_check_options AS s ON b.blockchain_id = s.blockchain_id
    LEFT JOIN LATERAL (
        SELECT json_agg(
                json_build_object(
                    'alias',
                    r.alias,
                    'loadBalancerID',
                    r.loadbalancer,
                    'domain',
                    r.domain
                )
            ) AS r
        FROM redirects AS r
        WHERE b.blockchain_id = r.blockchain_id
    ) redirects ON true
ORDER BY b.blockchain_id ASC
`

type SelectBlockchainsRow struct {
	BlockchainID      string          `json:"blockchainID"`
	Altruist          sql.NullString  `json:"altruist"`
	Blockchain        sql.NullString  `json:"blockchain"`
	BlockchainAliases []string        `json:"blockchainAliases"`
	ChainID           sql.NullString  `json:"chainID"`
	ChainIDCheck      sql.NullString  `json:"chainIDCheck"`
	Description       sql.NullString  `json:"description"`
	EnforceResult     sql.NullString  `json:"enforceResult"`
	LogLimitBlocks    sql.NullInt32   `json:"logLimitBlocks"`
	Network           sql.NullString  `json:"network"`
	Path              sql.NullString  `json:"path"`
	RequestTimeout    sql.NullInt32   `json:"requestTimeout"`
	Ticker            sql.NullString  `json:"ticker"`
	Active            sql.NullBool    `json:"active"`
	SSyncCheck        sql.NullString  `json:"sSyncCheck"`
	SAllowance        sql.NullInt32   `json:"sAllowance"`
	SBody             sql.NullString  `json:"sBody"`
	SPath             sql.NullString  `json:"sPath"`
	SResultKey        sql.NullString  `json:"sResultKey"`
	Redirects         json.RawMessage `json:"redirects"`
	CreatedAt         sql.NullTime    `json:"createdAt"`
	UpdatedAt         sql.NullTime    `json:"updatedAt"`
}

func (q *Queries) SelectBlockchains(ctx context.Context) ([]SelectBlockchainsRow, error) {
	rows, err := q.db.QueryContext(ctx, selectBlockchains)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectBlockchainsRow
	for rows.Next() {
		var i SelectBlockchainsRow
		if err := rows.Scan(
			&i.BlockchainID,
			&i.Altruist,
			&i.Blockchain,
			pq.Array(&i.BlockchainAliases),
			&i.ChainID,
			&i.ChainIDCheck,
			&i.Description,
			&i.EnforceResult,
			&i.LogLimitBlocks,
			&i.Network,
			&i.Path,
			&i.RequestTimeout,
			&i.Ticker,
			&i.Active,
			&i.SSyncCheck,
			&i.SAllowance,
			&i.SBody,
			&i.SPath,
			&i.SResultKey,
			&i.Redirects,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectGatewaySettings = `-- name: SelectGatewaySettings :one
SELECT gs.application_id AS application_id,
    gs.secret_key AS secret_key,
    gs.secret_key_required AS secret_key_required,
    gs.whitelist_blockchains AS whitelist_blockchains,
    json_agg(
        json_build_object(
            'blockchain_id',
            wc.blockchain_id,
            'contracts',
            wc.contracts
        )
    )::VARCHAR as whitelist_contracts,
    json_agg(
        json_build_object(
            'blockchain_id',
            wm.blockchain_id,
            'methods',
            wm.methods
        )
    )::VARCHAR as whitelist_methods,
    gs.whitelist_origins AS whitelist_origins,
    gs.whitelist_user_agents AS whitelist_user_agents
FROM gateway_settings AS gs
    LEFT JOIN whitelist_contracts AS wc ON gs.application_id = wc.application_id
    LEFT JOIN whitelist_methods AS wm ON gs.application_id = wm.application_id
WHERE gs.application_id = $1
`

type SelectGatewaySettingsRow struct {
	ApplicationID        string         `json:"applicationID"`
	SecretKey            sql.NullString `json:"secretKey"`
	SecretKeyRequired    sql.NullBool   `json:"secretKeyRequired"`
	WhitelistBlockchains []string       `json:"whitelistBlockchains"`
	WhitelistContracts   string         `json:"whitelistContracts"`
	WhitelistMethods     string         `json:"whitelistMethods"`
	WhitelistOrigins     []string       `json:"whitelistOrigins"`
	WhitelistUserAgents  []string       `json:"whitelistUserAgents"`
}

func (q *Queries) SelectGatewaySettings(ctx context.Context, applicationID string) (SelectGatewaySettingsRow, error) {
	row := q.db.QueryRowContext(ctx, selectGatewaySettings, applicationID)
	var i SelectGatewaySettingsRow
	err := row.Scan(
		&i.ApplicationID,
		&i.SecretKey,
		&i.SecretKeyRequired,
		pq.Array(&i.WhitelistBlockchains),
		&i.WhitelistContracts,
		&i.WhitelistMethods,
		pq.Array(&i.WhitelistOrigins),
		pq.Array(&i.WhitelistUserAgents),
	)
	return i, err
}

const selectLoadBalancers = `-- name: SelectLoadBalancers :many
SELECT lb.lb_id,
    lb.name,
    lb.request_timeout,
    lb.gigastake,
    lb.gigastake_redirect,
    lb.user_id,
    so.duration AS s_duration,
    so.sticky_max AS s_sticky_max,
    so.stickiness AS s_stickiness,
    so.origins AS s_origins,
    STRING_AGG(la.app_id, ',') AS app_ids,
    COALESCE(user_access.ua, '[]') AS users,
    lb.created_at,
    lb.updated_at
FROM loadbalancers AS lb
    LEFT JOIN stickiness_options AS so ON lb.lb_id = so.lb_id
    LEFT JOIN lb_apps AS la ON lb.lb_id = la.lb_id
    LEFT JOIN LATERAL (
        SELECT jsonb_agg(
                json_build_object(
                    'userID',
                    ua.user_id,
                    'roleName',
                    ua.role_name,
                    'email',
                    ua.email,
                    'accepted',
                    ua.accepted
                )
            ) AS ua
        FROM user_access AS ua
        WHERE lb.lb_id = ua.lb_id
    ) user_access ON true
GROUP BY lb.lb_id,
    lb.lb_id,
    lb.name,
    lb.created_at,
    lb.updated_at,
    lb.request_timeout,
    lb.gigastake,
    lb.gigastake_redirect,
    lb.user_id,
    so.duration,
    so.sticky_max,
    so.stickiness,
    so.origins,
    user_access.ua
ORDER BY lb.lb_id ASC
`

type SelectLoadBalancersRow struct {
	LbID              string          `json:"lbID"`
	Name              sql.NullString  `json:"name"`
	RequestTimeout    sql.NullInt32   `json:"requestTimeout"`
	Gigastake         sql.NullBool    `json:"gigastake"`
	GigastakeRedirect sql.NullBool    `json:"gigastakeRedirect"`
	UserID            sql.NullString  `json:"userID"`
	SDuration         sql.NullString  `json:"sDuration"`
	SStickyMax        sql.NullInt32   `json:"sStickyMax"`
	SStickiness       sql.NullBool    `json:"sStickiness"`
	SOrigins          []string        `json:"sOrigins"`
	AppIds            []byte          `json:"appIds"`
	Users             json.RawMessage `json:"users"`
	CreatedAt         sql.NullTime    `json:"createdAt"`
	UpdatedAt         sql.NullTime    `json:"updatedAt"`
}

func (q *Queries) SelectLoadBalancers(ctx context.Context) ([]SelectLoadBalancersRow, error) {
	rows, err := q.db.QueryContext(ctx, selectLoadBalancers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectLoadBalancersRow
	for rows.Next() {
		var i SelectLoadBalancersRow
		if err := rows.Scan(
			&i.LbID,
			&i.Name,
			&i.RequestTimeout,
			&i.Gigastake,
			&i.GigastakeRedirect,
			&i.UserID,
			&i.SDuration,
			&i.SStickyMax,
			&i.SStickiness,
			pq.Array(&i.SOrigins),
			&i.AppIds,
			&i.Users,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectNotificationSettings = `-- name: SelectNotificationSettings :one
SELECT application_id,
    signed_up,
    on_quarter,
    on_half,
    on_three_quarters,
    on_full
FROM notification_settings
WHERE application_id = $1
`

type SelectNotificationSettingsRow struct {
	ApplicationID   string       `json:"applicationID"`
	SignedUp        sql.NullBool `json:"signedUp"`
	OnQuarter       sql.NullBool `json:"onQuarter"`
	OnHalf          sql.NullBool `json:"onHalf"`
	OnThreeQuarters sql.NullBool `json:"onThreeQuarters"`
	OnFull          sql.NullBool `json:"onFull"`
}

func (q *Queries) SelectNotificationSettings(ctx context.Context, applicationID string) (SelectNotificationSettingsRow, error) {
	row := q.db.QueryRowContext(ctx, selectNotificationSettings, applicationID)
	var i SelectNotificationSettingsRow
	err := row.Scan(
		&i.ApplicationID,
		&i.SignedUp,
		&i.OnQuarter,
		&i.OnHalf,
		&i.OnThreeQuarters,
		&i.OnFull,
	)
	return i, err
}

const selectOneApplication = `-- name: SelectOneApplication :one
WITH app_whitelists AS (
    SELECT application_id
    FROM whitelist_contracts
    UNION
    SELECT application_id
    FROM whitelist_methods
)
SELECT a.application_id,
    a.contact_email,
    a.created_at,
    a.description,
    a.dummy,
    a.name,
    a.owner,
    a.status,
    a.updated_at,
    a.url,
    a.user_id,
    a.first_date_surpassed,
    ga.address AS ga_address,
    ga.client_public_key AS ga_client_public_key,
    ga.private_key AS ga_private_key,
    ga.public_key AS ga_public_key,
    ga.signature AS ga_signature,
    ga.version AS ga_version,
    gs.secret_key,
    gs.secret_key_required,
    gs.whitelist_blockchains,
    gs.whitelist_origins,
    gs.whitelist_user_agents,
    ns.signed_up,
    ns.on_quarter,
    ns.on_half,
    ns.on_three_quarters,
    ns.on_full,
    al.custom_limit,
    al.pay_plan,
    pp.daily_limit as plan_limit,
    CASE
        WHEN wc.application_id IS NOT NULL THEN json_agg(
            json_build_object(
                'blockchain_id',
                wc.blockchain_id,
                'contracts',
                wc.contracts
            )
        )::VARCHAR
        ELSE null
    END as whitelist_contracts,
    CASE
        WHEN wm.application_id IS NOT NULL THEN json_agg(
            json_build_object(
                'blockchain_id',
                wm.blockchain_id,
                'methods',
                wm.methods
            )
        )::VARCHAR
        ELSE null
    END as whitelist_methods
FROM applications AS a
    LEFT JOIN gateway_aat AS ga ON a.application_id = ga.application_id
    LEFT JOIN gateway_settings AS gs ON a.application_id = gs.application_id
    LEFT JOIN notification_settings AS ns ON a.application_id = ns.application_id
    LEFT JOIN app_limits AS al ON a.application_id = al.application_id
    LEFT JOIN pay_plans AS pp ON al.pay_plan = pp.plan_type
    LEFT JOIN whitelist_contracts wc ON a.application_id = wc.application_id
    LEFT JOIN whitelist_methods wm ON a.application_id = wm.application_id
WHERE a.application_id = $1
GROUP BY a.application_id,
    a.contact_email,
    a.created_at,
    a.description,
    a.dummy,
    a.name,
    a.owner,
    a.status,
    a.updated_at,
    a.url,
    a.user_id,
    a.first_date_surpassed,
    ga.address,
    ga.client_public_key,
    ga.private_key,
    ga.public_key,
    ga.signature,
    ga.version,
    gs.secret_key,
    gs.secret_key_required,
    gs.whitelist_blockchains,
    gs.whitelist_origins,
    gs.whitelist_user_agents,
    ns.signed_up,
    ns.on_quarter,
    ns.on_half,
    ns.on_three_quarters,
    ns.on_full,
    al.custom_limit,
    al.pay_plan,
    pp.daily_limit,
    wc.application_id,
    wm.application_id
`

type SelectOneApplicationRow struct {
	ApplicationID        string         `json:"applicationID"`
	ContactEmail         sql.NullString `json:"contactEmail"`
	CreatedAt            sql.NullTime   `json:"createdAt"`
	Description          sql.NullString `json:"description"`
	Dummy                sql.NullBool   `json:"dummy"`
	Name                 sql.NullString `json:"name"`
	Owner                sql.NullString `json:"owner"`
	Status               sql.NullString `json:"status"`
	UpdatedAt            sql.NullTime   `json:"updatedAt"`
	Url                  sql.NullString `json:"url"`
	UserID               sql.NullString `json:"userID"`
	FirstDateSurpassed   sql.NullTime   `json:"firstDateSurpassed"`
	GaAddress            sql.NullString `json:"gaAddress"`
	GaClientPublicKey    sql.NullString `json:"gaClientPublicKey"`
	GaPrivateKey         sql.NullString `json:"gaPrivateKey"`
	GaPublicKey          sql.NullString `json:"gaPublicKey"`
	GaSignature          sql.NullString `json:"gaSignature"`
	GaVersion            sql.NullString `json:"gaVersion"`
	SecretKey            sql.NullString `json:"secretKey"`
	SecretKeyRequired    sql.NullBool   `json:"secretKeyRequired"`
	WhitelistBlockchains []string       `json:"whitelistBlockchains"`
	WhitelistOrigins     []string       `json:"whitelistOrigins"`
	WhitelistUserAgents  []string       `json:"whitelistUserAgents"`
	SignedUp             sql.NullBool   `json:"signedUp"`
	OnQuarter            sql.NullBool   `json:"onQuarter"`
	OnHalf               sql.NullBool   `json:"onHalf"`
	OnThreeQuarters      sql.NullBool   `json:"onThreeQuarters"`
	OnFull               sql.NullBool   `json:"onFull"`
	CustomLimit          sql.NullInt32  `json:"customLimit"`
	PayPlan              sql.NullString `json:"payPlan"`
	PlanLimit            sql.NullInt32  `json:"planLimit"`
	WhitelistContracts   interface{}    `json:"whitelistContracts"`
	WhitelistMethods     interface{}    `json:"whitelistMethods"`
}

func (q *Queries) SelectOneApplication(ctx context.Context, applicationID string) (SelectOneApplicationRow, error) {
	row := q.db.QueryRowContext(ctx, selectOneApplication, applicationID)
	var i SelectOneApplicationRow
	err := row.Scan(
		&i.ApplicationID,
		&i.ContactEmail,
		&i.CreatedAt,
		&i.Description,
		&i.Dummy,
		&i.Name,
		&i.Owner,
		&i.Status,
		&i.UpdatedAt,
		&i.Url,
		&i.UserID,
		&i.FirstDateSurpassed,
		&i.GaAddress,
		&i.GaClientPublicKey,
		&i.GaPrivateKey,
		&i.GaPublicKey,
		&i.GaSignature,
		&i.GaVersion,
		&i.SecretKey,
		&i.SecretKeyRequired,
		pq.Array(&i.WhitelistBlockchains),
		pq.Array(&i.WhitelistOrigins),
		pq.Array(&i.WhitelistUserAgents),
		&i.SignedUp,
		&i.OnQuarter,
		&i.OnHalf,
		&i.OnThreeQuarters,
		&i.OnFull,
		&i.CustomLimit,
		&i.PayPlan,
		&i.PlanLimit,
		&i.WhitelistContracts,
		&i.WhitelistMethods,
	)
	return i, err
}

const selectOneLoadBalancer = `-- name: SelectOneLoadBalancer :one
SELECT lb.lb_id,
    lb.name,
    lb.request_timeout,
    lb.gigastake,
    lb.gigastake_redirect,
    lb.user_id,
    so.duration,
    so.sticky_max,
    so.stickiness,
    so.origins,
    STRING_AGG(la.app_id, ',') AS app_ids,
    COALESCE(user_access.ua, '[]') AS users,
    lb.created_at,
    lb.updated_at
FROM loadbalancers AS lb
    LEFT JOIN stickiness_options AS so ON lb.lb_id = so.lb_id
    LEFT JOIN lb_apps AS la ON lb.lb_id = la.lb_id
    LEFT JOIN LATERAL (
        SELECT jsonb_agg(
                json_build_object(
                    'userID',
                    ua.user_id,
                    'roleName',
                    ua.role_name,
                    'email',
                    ua.email,
                    'accepted',
                    ua.accepted
                )
            ) AS ua
        FROM user_access AS ua
        WHERE lb.lb_id = ua.lb_id
    ) user_access ON true
WHERE lb.lb_id = $1
GROUP BY lb.lb_id,
    lb.lb_id,
    lb.name,
    lb.created_at,
    lb.updated_at,
    lb.request_timeout,
    lb.gigastake,
    lb.gigastake_redirect,
    lb.user_id,
    so.duration,
    so.sticky_max,
    so.stickiness,
    so.origins,
    user_access.ua
`

type SelectOneLoadBalancerRow struct {
	LbID              string          `json:"lbID"`
	Name              sql.NullString  `json:"name"`
	RequestTimeout    sql.NullInt32   `json:"requestTimeout"`
	Gigastake         sql.NullBool    `json:"gigastake"`
	GigastakeRedirect sql.NullBool    `json:"gigastakeRedirect"`
	UserID            sql.NullString  `json:"userID"`
	Duration          sql.NullString  `json:"duration"`
	StickyMax         sql.NullInt32   `json:"stickyMax"`
	Stickiness        sql.NullBool    `json:"stickiness"`
	Origins           []string        `json:"origins"`
	AppIds            []byte          `json:"appIds"`
	Users             json.RawMessage `json:"users"`
	CreatedAt         sql.NullTime    `json:"createdAt"`
	UpdatedAt         sql.NullTime    `json:"updatedAt"`
}

func (q *Queries) SelectOneLoadBalancer(ctx context.Context, lbID string) (SelectOneLoadBalancerRow, error) {
	row := q.db.QueryRowContext(ctx, selectOneLoadBalancer, lbID)
	var i SelectOneLoadBalancerRow
	err := row.Scan(
		&i.LbID,
		&i.Name,
		&i.RequestTimeout,
		&i.Gigastake,
		&i.GigastakeRedirect,
		&i.UserID,
		&i.Duration,
		&i.StickyMax,
		&i.Stickiness,
		pq.Array(&i.Origins),
		&i.AppIds,
		&i.Users,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const selectPayPlans = `-- name: SelectPayPlans :many
SELECT plan_type,
    daily_limit
FROM pay_plans
ORDER BY plan_type ASC
`

type SelectPayPlansRow struct {
	PlanType   string `json:"planType"`
	DailyLimit int32  `json:"dailyLimit"`
}

func (q *Queries) SelectPayPlans(ctx context.Context) ([]SelectPayPlansRow, error) {
	rows, err := q.db.QueryContext(ctx, selectPayPlans)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectPayPlansRow
	for rows.Next() {
		var i SelectPayPlansRow
		if err := rows.Scan(&i.PlanType, &i.DailyLimit); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectUserRoles = `-- name: SelectUserRoles :many
SELECT ua.lb_id,
    ua.user_id,
    ur.permissions as permissions
FROM user_access as ua
    LEFT JOIN user_roles AS ur ON ua.role_name = ur.name
`

type SelectUserRolesRow struct {
	LbID        sql.NullString          `json:"lbID"`
	UserID      sql.NullString          `json:"userID"`
	Permissions []types.PermissionsEnum `json:"permissions"`
}

func (q *Queries) SelectUserRoles(ctx context.Context) ([]SelectUserRolesRow, error) {
	rows, err := q.db.QueryContext(ctx, selectUserRoles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectUserRolesRow
	for rows.Next() {
		var i SelectUserRolesRow
		if err := rows.Scan(&i.LbID, &i.UserID, pq.Array(&i.Permissions)); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFirstDateSurpassed = `-- name: UpdateFirstDateSurpassed :exec
UPDATE applications
SET first_date_surpassed = $1
WHERE application_id = ANY ($2::VARCHAR [])
`

type UpdateFirstDateSurpassedParams struct {
	FirstDateSurpassed sql.NullTime `json:"firstDateSurpassed"`
	ApplicationIds     []string     `json:"applicationIds"`
}

func (q *Queries) UpdateFirstDateSurpassed(ctx context.Context, arg UpdateFirstDateSurpassedParams) error {
	_, err := q.db.ExecContext(ctx, updateFirstDateSurpassed, arg.FirstDateSurpassed, pq.Array(arg.ApplicationIds))
	return err
}

const updateLB = `-- name: UpdateLB :exec
UPDATE loadbalancers AS l
SET name = COALESCE($2, l.name),
    updated_at = $3
WHERE l.lb_id = $1
`

type UpdateLBParams struct {
	LbID      string         `json:"lbID"`
	Name      sql.NullString `json:"name"`
	UpdatedAt sql.NullTime   `json:"updatedAt"`
}

func (q *Queries) UpdateLB(ctx context.Context, arg UpdateLBParams) error {
	_, err := q.db.ExecContext(ctx, updateLB, arg.LbID, arg.Name, arg.UpdatedAt)
	return err
}

const updateUserAccess = `-- name: UpdateUserAccess :exec
UPDATE user_access as ua
SET role_name = COALESCE($3, ua.role_name),
    updated_at = $4
WHERE ua.user_id = $1
    AND ua.lb_id = $2
`

type UpdateUserAccessParams struct {
	UserID    sql.NullString `json:"userID"`
	LbID      sql.NullString `json:"lbID"`
	RoleName  sql.NullString `json:"roleName"`
	UpdatedAt sql.NullTime   `json:"updatedAt"`
}

func (q *Queries) UpdateUserAccess(ctx context.Context, arg UpdateUserAccessParams) error {
	_, err := q.db.ExecContext(ctx, updateUserAccess,
		arg.UserID,
		arg.LbID,
		arg.RoleName,
		arg.UpdatedAt,
	)
	return err
}

const upsertAppLimit = `-- name: UpsertAppLimit :exec
INSERT INTO app_limits AS al (
        application_id,
        pay_plan,
        custom_limit
    )
VALUES ($1, $2, $3) ON CONFLICT (application_id) DO
UPDATE
SET pay_plan = COALESCE(EXCLUDED.pay_plan, al.pay_plan),
    custom_limit = COALESCE(EXCLUDED.custom_limit, al.custom_limit)
`

type UpsertAppLimitParams struct {
	ApplicationID string        `json:"applicationID"`
	PayPlan       string        `json:"payPlan"`
	CustomLimit   sql.NullInt32 `json:"customLimit"`
}

func (q *Queries) UpsertAppLimit(ctx context.Context, arg UpsertAppLimitParams) error {
	_, err := q.db.ExecContext(ctx, upsertAppLimit, arg.ApplicationID, arg.PayPlan, arg.CustomLimit)
	return err
}

const upsertApplication = `-- name: UpsertApplication :exec
INSERT INTO applications AS a (
        application_id,
        name,
        status,
        first_date_surpassed,
        updated_at
    )
VALUES ($1, $2, $3, $4, $5) ON CONFLICT (application_id) DO
UPDATE
SET name = COALESCE(EXCLUDED.name, a.name),
    status = COALESCE(EXCLUDED.status, a.status),
    first_date_surpassed = COALESCE(
        EXCLUDED.first_date_surpassed,
        a.first_date_surpassed
    )
`

type UpsertApplicationParams struct {
	ApplicationID      string         `json:"applicationID"`
	Name               sql.NullString `json:"name"`
	Status             sql.NullString `json:"status"`
	FirstDateSurpassed sql.NullTime   `json:"firstDateSurpassed"`
	UpdatedAt          sql.NullTime   `json:"updatedAt"`
}

func (q *Queries) UpsertApplication(ctx context.Context, arg UpsertApplicationParams) error {
	_, err := q.db.ExecContext(ctx, upsertApplication,
		arg.ApplicationID,
		arg.Name,
		arg.Status,
		arg.FirstDateSurpassed,
		arg.UpdatedAt,
	)
	return err
}

const upsertGatewaySettings = `-- name: UpsertGatewaySettings :exec
INSERT INTO gateway_settings AS gs (
        application_id,
        secret_key,
        secret_key_required,
        whitelist_origins,
        whitelist_user_agents,
        whitelist_blockchains
    )
VALUES ($1, $2, $3, $4, $5, $6) ON CONFLICT (application_id) DO
UPDATE
SET secret_key = COALESCE(EXCLUDED.secret_key, gs.secret_key),
    secret_key_required = COALESCE(
        EXCLUDED.secret_key_required,
        gs.secret_key_required
    ),
    whitelist_origins = COALESCE(EXCLUDED.whitelist_origins, gs.whitelist_origins),
    whitelist_user_agents = COALESCE(
        EXCLUDED.whitelist_user_agents,
        gs.whitelist_user_agents
    ),
    whitelist_blockchains = COALESCE(
        EXCLUDED.whitelist_blockchains,
        gs.whitelist_blockchains
    )
`

type UpsertGatewaySettingsParams struct {
	ApplicationID        string         `json:"applicationID"`
	SecretKey            sql.NullString `json:"secretKey"`
	SecretKeyRequired    sql.NullBool   `json:"secretKeyRequired"`
	WhitelistOrigins     []string       `json:"whitelistOrigins"`
	WhitelistUserAgents  []string       `json:"whitelistUserAgents"`
	WhitelistBlockchains []string       `json:"whitelistBlockchains"`
}

func (q *Queries) UpsertGatewaySettings(ctx context.Context, arg UpsertGatewaySettingsParams) error {
	_, err := q.db.ExecContext(ctx, upsertGatewaySettings,
		arg.ApplicationID,
		arg.SecretKey,
		arg.SecretKeyRequired,
		pq.Array(arg.WhitelistOrigins),
		pq.Array(arg.WhitelistUserAgents),
		pq.Array(arg.WhitelistBlockchains),
	)
	return err
}

const upsertNotificationSettings = `-- name: UpsertNotificationSettings :exec
INSERT INTO notification_settings AS ns (
        application_id,
        signed_up,
        on_quarter,
        on_half,
        on_three_quarters,
        on_full
    )
VALUES ($1, $2, $3, $4, $5, $6) ON CONFLICT (application_id) DO
UPDATE
SET signed_up = COALESCE(EXCLUDED.signed_up, ns.signed_up),
    on_quarter = COALESCE(EXCLUDED.on_quarter, ns.on_quarter),
    on_half = COALESCE(EXCLUDED.on_half, ns.on_half),
    on_three_quarters = COALESCE(EXCLUDED.on_three_quarters, ns.on_three_quarters),
    on_full = COALESCE(EXCLUDED.on_full, ns.on_full)
`

type UpsertNotificationSettingsParams struct {
	ApplicationID   string       `json:"applicationID"`
	SignedUp        sql.NullBool `json:"signedUp"`
	OnQuarter       sql.NullBool `json:"onQuarter"`
	OnHalf          sql.NullBool `json:"onHalf"`
	OnThreeQuarters sql.NullBool `json:"onThreeQuarters"`
	OnFull          sql.NullBool `json:"onFull"`
}

func (q *Queries) UpsertNotificationSettings(ctx context.Context, arg UpsertNotificationSettingsParams) error {
	_, err := q.db.ExecContext(ctx, upsertNotificationSettings,
		arg.ApplicationID,
		arg.SignedUp,
		arg.OnQuarter,
		arg.OnHalf,
		arg.OnThreeQuarters,
		arg.OnFull,
	)
	return err
}

const upsertStickinessOptions = `-- name: UpsertStickinessOptions :exec
INSERT INTO stickiness_options AS so (
        lb_id,
        duration,
        sticky_max,
        stickiness,
        origins
    )
VALUES ($1, $2, $3, $4, $5) ON CONFLICT (lb_id) DO
UPDATE
SET duration = COALESCE(EXCLUDED.duration, so.duration),
    sticky_max = COALESCE(EXCLUDED.sticky_max, so.sticky_max),
    stickiness = COALESCE(EXCLUDED.stickiness, so.stickiness),
    origins = COALESCE(EXCLUDED.origins, so.origins)
`

type UpsertStickinessOptionsParams struct {
	LbID       string         `json:"lbID"`
	Duration   sql.NullString `json:"duration"`
	StickyMax  sql.NullInt32  `json:"stickyMax"`
	Stickiness sql.NullBool   `json:"stickiness"`
	Origins    []string       `json:"origins"`
}

func (q *Queries) UpsertStickinessOptions(ctx context.Context, arg UpsertStickinessOptionsParams) error {
	_, err := q.db.ExecContext(ctx, upsertStickinessOptions,
		arg.LbID,
		arg.Duration,
		arg.StickyMax,
		arg.Stickiness,
		pq.Array(arg.Origins),
	)
	return err
}

const upsertWhitelistContracts = `-- name: UpsertWhitelistContracts :exec
WITH data (application_id, blockchain_id, contracts) AS (
    VALUES (
            $1::VARCHAR,
            $2::VARCHAR,
            $3::VARCHAR []
        )
)
INSERT INTO whitelist_contracts (application_id, blockchain_id, contracts)
SELECT application_id,
    blockchain_id,
    contracts
FROM data ON CONFLICT (application_id, blockchain_id) DO
UPDATE
SET contracts = excluded.contracts
`

type UpsertWhitelistContractsParams struct {
	ApplicationID string   `json:"applicationID"`
	BlockchainID  string   `json:"blockchainID"`
	Contracts     []string `json:"contracts"`
}

func (q *Queries) UpsertWhitelistContracts(ctx context.Context, arg UpsertWhitelistContractsParams) error {
	_, err := q.db.ExecContext(ctx, upsertWhitelistContracts, arg.ApplicationID, arg.BlockchainID, pq.Array(arg.Contracts))
	return err
}

const upsertWhitelistMethods = `-- name: UpsertWhitelistMethods :exec
WITH data (application_id, blockchain_id, methods) AS (
    VALUES (
            $1::VARCHAR,
            $2::VARCHAR,
            $3::VARCHAR []
        )
)
INSERT INTO whitelist_methods (application_id, blockchain_id, methods)
SELECT application_id,
    blockchain_id,
    methods::VARCHAR []
FROM data ON CONFLICT (application_id, blockchain_id) DO
UPDATE
SET methods = EXCLUDED.methods
`

type UpsertWhitelistMethodsParams struct {
	ApplicationID string   `json:"applicationID"`
	BlockchainID  string   `json:"blockchainID"`
	Methods       []string `json:"methods"`
}

func (q *Queries) UpsertWhitelistMethods(ctx context.Context, arg UpsertWhitelistMethodsParams) error {
	_, err := q.db.ExecContext(ctx, upsertWhitelistMethods, arg.ApplicationID, arg.BlockchainID, pq.Array(arg.Methods))
	return err
}
